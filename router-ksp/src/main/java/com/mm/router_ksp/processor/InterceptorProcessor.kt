package com.mm.router_ksp.processor

import com.google.auto.service.AutoService
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSFile
import com.mm.annotation.RouterInterceptor
import com.mm.annotation.model.InterceptorMeta
import com.mm.router_ksp.utils.INTERCEPTOR_CREATOR
import com.mm.router_ksp.utils.findAnnotationWithType
import com.mm.router_ksp.utils.findModuleName
import com.mm.router_ksp.utils.quantifyNameToClassName
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.STRING
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import com.squareup.kotlinpoet.ksp.writeTo


/**
 * Date : 2023/5/27
 */
class InterceptorProcessor(
    private val logger: KSPLogger,
    private val codeGenerator: CodeGenerator,
    options: Map<String, String>
) :
    SymbolProcessor {
    private val moduleName = options.findModuleName(logger)
    private val WARNING_TIPS = "DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY ROUTER."
    private val NAME_OF_INTERCEPTOR = "\$\$InterceptorCreator"

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbol = resolver.getSymbolsWithAnnotation(RouterInterceptor::class.qualifiedName!!)
        val elements = symbol.filterIsInstance<KSClassDeclaration>().toList()
        if (elements.isNotEmpty()) {
            logger.info(">>> InterceptorSymbolProcessor init. <<<")
            try {
                parseRoute(elements)
            } catch (e: Exception) {
                logger.exception(e)
            }
        }
        return emptyList()
    }

    private fun parseRoute(elements: List<KSClassDeclaration>) {
        val map = ClassName("java.util", "HashMap")
        val parameterSpec = ParameterSpec.builder(
            "interceptors", map.parameterizedBy(
                STRING, InterceptorMeta::class.asTypeName()
            ).copy(nullable = false)
        ).build()

        val funSpecBuild = FunSpec.builder("intercept").addModifiers(KModifier.OVERRIDE).addParameter(parameterSpec)
        var packageName: String = javaClass.getPackage().name

        val groupFileDependencies = mutableSetOf<KSFile>()
        elements.forEach {
            if (it.classKind != ClassKind.CLASS) {
                error("Only Classes can be annotated with " + RouterInterceptor::class.java.canonicalName)
            }
            val qualifiedName = it.qualifiedName?.asString()
                ?: error("local variable can not be annotated with @RouterInterceptor")
            packageName = qualifiedName.substring(0, qualifiedName.lastIndexOf("."))
            val interceptor =
                it.findAnnotationWithType<RouterInterceptor>() ?: error("$qualifiedName must annotated with @RouterInterceptor")

            funSpecBuild.addStatement(
                "interceptors.put(%S, %T.build(%S,%L,%T(),%S))",
                interceptor.value,
                InterceptorMeta::class,
                interceptor.value,
                interceptor.priority,
                it.qualifiedName!!.asString().quantifyNameToClassName(),
                interceptor.des
            )
            if (interceptor.des.isNotEmpty()) {
                funSpecBuild.addKdoc(CodeBlock.of(interceptor.des))
            }
            it.containingFile?.let { file ->
                groupFileDependencies.add(file)
            }
        }
        val className = moduleName + NAME_OF_INTERCEPTOR
        val file = FileSpec.builder(packageName, className)
            .addType(
                TypeSpec.classBuilder(ClassName(packageName, className))
                    .addSuperinterface(INTERCEPTOR_CREATOR.quantifyNameToClassName())
                    .addFunction(funSpecBuild.build())
                    .addKdoc(CodeBlock.of("$WARNING_TIPS\n自动收集 [${RouterInterceptor::class.qualifiedName}] 路由"))
                    .addAnnotation(
                        AnnotationSpec.builder(AutoService::class)
                            .addMember(
                                CodeBlock.of(
                                    "%T::class",
                                    INTERCEPTOR_CREATOR.quantifyNameToClassName()
                                )
                            )
                            .build()
                    )
                    .build()
            )
            .build()
        file.writeTo(codeGenerator, true, groupFileDependencies)
    }
}