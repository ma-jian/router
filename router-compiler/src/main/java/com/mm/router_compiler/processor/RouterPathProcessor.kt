package com.mm.router_compiler.processor

import com.google.auto.service.AutoService
import com.mm.annotation.RouterPath
import com.mm.annotation.model.RouterMeta
import com.mm.annotation.model.RouterType
import com.mm.router_compiler.BaseAbstractProcessor
import com.mm.router_compiler.inter.IProcessor
import com.squareup.javapoet.AnnotationSpec
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.CodeBlock
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.ParameterSpec
import com.squareup.javapoet.ParameterizedTypeName
import com.squareup.javapoet.TypeSpec
import java.io.IOException
import javax.annotation.processing.Messager
import javax.annotation.processing.RoundEnvironment
import javax.lang.model.element.Element
import javax.lang.model.element.ElementKind
import javax.lang.model.element.Modifier
import javax.lang.model.type.TypeMirror
import javax.lang.model.util.ElementFilter
import javax.tools.Diagnostic

/**
 * 注解处理器处理[RouterPath] 对路由进行注册
 */

class RouterPathProcessor : IProcessor {
    private val WARNING_TIPS = "DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY ROUTER."
    private val NAME_OF_AUTOROUTER = "\$\$AutoRouterCreator"

    private lateinit var messager: Messager

    override fun process(roundEnv: RoundEnvironment, abstractProcessor: BaseAbstractProcessor) {
        val types = abstractProcessor.mTypes
        val elementUtils = abstractProcessor.mElements
        messager = abstractProcessor.mMessager
        try {
            val elements: Set<Element>? = roundEnv.getElementsAnnotatedWith(RouterPath::class.java)
            if (elements.isNullOrEmpty()) {
                return
            }
            val parameterizedTypeName: ParameterizedTypeName = ParameterizedTypeName.get(
                ClassName.get(HashMap::class.java),
                ClassName.get(String::class.java),
                ClassName.get(RouterMeta::class.java)
            )
            val parameterSpec: ParameterSpec = ParameterSpec.builder(parameterizedTypeName, "rules").build()
            val methodSpecBuilder: MethodSpec.Builder = MethodSpec.methodBuilder("initRule")
                .addAnnotation(Override::class.java)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(parameterSpec)
            val activityTm: TypeMirror = elementUtils.getTypeElement(IProcessor.ACTIVITY).asType()
            val fragmentX: TypeMirror = elementUtils.getTypeElement(IProcessor.FRAGMENT_X).asType()
            val fragmentTm: TypeMirror = elementUtils.getTypeElement(IProcessor.FRAGMENT).asType()
            val iProvider = elementUtils.getTypeElement(IProcessor.IPROVIDER).asType()
            val service = elementUtils.getTypeElement(IProcessor.SERVICE).asType()
            var packageName: String = javaClass.getPackage().name
            for (typeElement in ElementFilter.typesIn(roundEnv.getElementsAnnotatedWith(RouterPath::class.java))) {
                if (typeElement.kind != ElementKind.CLASS) {
                    error("Only Classes can be annotated with " + RouterPath::class.java.canonicalName)
                    return
                }
                val qualifiedName = typeElement.qualifiedName.toString()
                packageName = qualifiedName.substring(0, qualifiedName.lastIndexOf("."))
                val router: RouterPath = typeElement.getAnnotation(RouterPath::class.java)
                val tm: TypeMirror = typeElement.asType()
                var routerType: RouterType
                // Activity or Fragment
                if (types.isSubtype(tm, activityTm) || types.isSubtype(tm, fragmentX) || types.isSubtype(tm, fragmentTm)) {
                    // Get all fields annotation by @Autowired
                    routerType = if (types.isSubtype(tm, activityTm)) {
                        // Activity
                        RouterType.ACTIVITY
                    } else {
                        // Fragment
                        RouterType.FRAGMENT
                    }
                } else if (types.isSubtype(tm, iProvider)) {
                    // IProvider
                    routerType = RouterType.PROVIDER
                } else if (types.isSubtype(tm, service)) {
                    // Service
                    routerType = RouterType.SERVICE
                } else {
                    throw RuntimeException("The @Router is marked on unsupported class, look at [$tm].")
                }

                val builder = StringBuilder("new String[]{")
                router.interceptor.forEachIndexed { index, s ->
                    builder.append("\"$s\"")
                    if (index < router.interceptor.size - 1) {
                        builder.append(",")
                    }
                }
                builder.append("}")

                methodSpecBuilder.addStatement(
                    "rules.put(\$S, \$T.build(\$T.$routerType, \$S, \$T.class, \$S, ${builder}))",
                    router.value,
                    ClassName.get(RouterMeta::class.java),
                    ClassName.get(RouterType::class.java),
                    router.value,
                    typeElement,
                    router.des
                )
            }
            val methodSpec: MethodSpec = methodSpecBuilder.build()
            val moduleName = abstractProcessor.moduleName
            val className = moduleName + NAME_OF_AUTOROUTER
            val typeSpec: TypeSpec = TypeSpec.classBuilder(className)
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(
                    AnnotationSpec.builder(AutoService::class.java)
                        .addMember(
                            "value",
                            "\$T.class",
                            abstractProcessor.mElements.getTypeElement(BaseAbstractProcessor.ROUTER_INTERFACE_PATH)
                        )
                        .build()
                )
                .addSuperinterface(ClassName.get(abstractProcessor.mElements.getTypeElement(BaseAbstractProcessor.ROUTER_INTERFACE_PATH)))
                .addMethod(methodSpec)
                .addJavadoc(CodeBlock.of("$WARNING_TIPS\n自动收集 {@link \$T} 路由", RouterPath::class.java))
                .build()
            JavaFile.builder(packageName, typeSpec).build().writeTo(abstractProcessor.mFiler)
        } catch (e: IOException) {
            error(e.message)
        } catch (e: Exception) {
            error(e.message)
        }
    }

    private fun error(error: String?) {
        messager.printMessage(Diagnostic.Kind.ERROR, this.javaClass.canonicalName + " : " + error)
    }

    private fun info(error: String) {
        messager.printMessage(Diagnostic.Kind.WARNING, this.javaClass.canonicalName + " : " + error)
    }
}